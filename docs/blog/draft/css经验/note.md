# CSS 经验



1. 必须引入 reset.css，不要用 normalize.css
2. 任何元素必须设置宽高，不然有些效果不会显现，比如基于 margin 的居中
3. box-sizing 使用 border-box 而不是默认的 content-box





用 animation 配合 @keyframes 而不是 transition：

1. 在调试时会带来很多麻烦。惯常书写的 `transition: all 1s;` 这里面的 all 就非常坑，语义及其不明确，并且可能带来隐患，比如本来不希望有过渡过程的属性改变，现在也会被 all 给捕获到。而 animation 有着对应的 @keyframe 名称，一看就知道，语义清晰。
2. 难扩展，transition 可以看做某种意义上的二帧动画，如果突然想将动效扩展就会麻烦。而 @keyframe 要扩展实在是非常简单。


> 比较常见的实践是用多种分辨率来测试一个网站,然后添加越来越多的
媒体查询(Media Query)规则来修补网站在这些分辨率下出现的问题。然
而对于今后的 CSS 改动来说,每个媒体查询都会增加成本,而这种成本是
不应轻易上升的。未来每次对 CSS 代码的修改都要求我们逐一核对这些媒
体查询是否需要配合修改,甚至可能要求我们反过来修改这些媒体查询的设
置。这一点常常被我们忽略,后患无穷。你添加的媒体查询越多,你的 CSS
代码就会变得越来越经不起折腾。《CSS 揭秘》


下面还有一些建议,可能会帮你避免不必要的媒体查询。

* 使用百分比长度来取代固定长度。如果实在做不到这一点,也应该
尝试使用与视口相关的单位( vw 、 vh 、 vmin 和 vmax ),它们的值解
析为视口宽度或高度的百分比。
* 当你需要在较大分辨率下得到固定宽度时,使用 max-width 而不是
width ,因为它可以适应较小的分辨率,而无需使用媒体查询。
* 不要忘记为替换元素(比如 img 、 object 、 video 、 iframe 等)设
置一个 max-width ,值为 100% 。
* 假如背景图片需要完整地铺满一个容器,不管容器的尺寸如何变化,
background-size: cover 这个属性都可以做到。但是,我们也要时
刻牢记——带宽并不是无限的,因此在移动网页中通过 CSS 把一张
大图缩小显示往往是不太明智的。
* 当图片(或其他元素)以行列式进行布局时,让视口的宽度来决定
列的数量。弹性盒布局(即 Flexbox)或者 display: inline-block
加上常规的文本折行行为,都可以实现这一点。
* 在 使 用 多 列 文 本 时, 指 定 column-width ( 列 宽 ) 而 不 是 指 定
column-count (列数)
,这样它就可以在较小的屏幕上自动显示为单
列布局。


你可能知道,以下两行 CSS 代码并不是等价的:
```css
background: rebeccapurple;
background-color: rebeccapurple;
```
前者是简写,它可以确保你得到 rebeccapurple 纯色背景;但如果
你用的是展开式的单个属性( background-color ),那这个元素的背景最终
有可能会显示为一个粉色的渐变图案、一张猫的图片或其他任何东西,因为
同时可能会有一条 background-image 声明在起作用。在使用展开式属性的
写法时,通常会遇到这样的问题:展开式写法并不会帮助你清空所有相关的
其他属性,从而可能会干扰你想要达到的效果。

当然,你可以把所有的展开式属性全都设置一遍,然后收工,但你可能
会漏掉几个;又或者,CSS 工作组可能会在未来引入更多的展开式属性,那
时你的代码就无法完全覆盖它们了。不要害怕使用简写属性。合理使用简写
是一种良好的防卫性编码方式,可以抵御未来的风险。当然,如果我们要明
确地去覆盖某个具体的展开式属性并保留其他相关样式,那就需要用展开式
属性,就像我们在“尽量减少代码重复”一节中为了得到按钮的其他颜色版
本所做的那样。


