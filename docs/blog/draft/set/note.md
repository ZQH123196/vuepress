---
typora-root-url: ./
---

# 仿 VUE2 的双向数据绑定

首先，要明确 Vue2 是怎么做的，我们打印一个 Vue2 项目的数据：

![1554538900539](/note.assets/1554538900539.png)

看 x、y、z 都没有立即显示其值，说明其是地址，鼠标点击引擎就会通过下面的 get 函数来获取其值。

怎么会是不能直接显示值？原因在于这个 $data 对象其实并非源数据的对象，而是一个代理对象。

为了方便起见，称代理对象为 P(Proxy)，另一个则是源数据对象 O(Origin)。

先传入 O，然后创建一个对象 P，P 将代理 O 全部的数据，并且将



最后，让我们处理掉复杂数据类型的问题。

有趣的是，这个新对象其实内部没有值，有的只是各种 get、set 函数，但是虽然外部获取值时看上去是读取这个新对象的 x、y、z 值，但由于取对应值的函数被设置为返回 Data 区域的数据，所以看似读取的是新对象，暗地里却被换了东西。

即使这个新对象里面有自己的 x、y、z 值，也永远不能在被取到了，也许这才是**劫持**的真正含义。可以说新对象劫持了源数据，也可以说我们迫使新对象放弃了自己与源数据重名的属性。

> 当然，在设计的时候，代理对象就不应该拥有任何属于自己的属性。

在尝试一下 ES6 的魅力：



如果内部是引用类型，set 就不会生效了，因为引用类型内部存放的是地址位置。set 不能对引用类型生效，那么我们就必须为引用内存区内的所有非引用类型进行代理，一直递归到确保没有值类型被忽略掉。

前面添加一个拦截：，比如有个意识，那就是不管对于任意递归的函数来说，在此行拦截代码之下，必定是值类型，因此就能确保所有的东西都被代理到。







当代理全部完成之后，将 O = P，这个时候，源对象 O 原本的数据区域 Data 就没有一个明确的指针指向它了，但 Data 区域内的数据由于全部都被代理了，也就是 P 内的代理函数将会指向 Data 内的数据，因此 Data 区域不会被引擎所释放，此时 Data 内的数据只能由代理对象 P 来访问了。这样 Data 内的数据就仅有一个读取和写入的途径了，不会再有其他的，最大限度的保护的数据，通过限制的方式。

每一层的引用，都将有一个专门用于代理的对象。