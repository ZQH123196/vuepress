单元测试是真滴烦人，不过却是一个梳理需求的好东西，很多大公司甚至是先写单元测试（需求），再写代码的，因为在书写单元测试时就是在进行接口跟功能的设计，效果比 UML 要强上十倍，毕竟比 UML 图要更贴近实际。

但是啊，要记住，为一个根本不会犯的错误写测试，这是一件很愚蠢且没有营养的事情。



但是，怎么说呢！除非你的编程语言类型系统足够强大，能几乎在编译期间找出几乎全部的bug，你才不需要单元测试。

换句话说，用着简单的编程语言的同学（就是python，java，ruby，php，c，c++等），必须写单元测试。

TDD （Test-Driven Development）测试驱动开发

https://mp.weixin.qq.com/s/KCrkL4NeuZeZvTu5Sc6B_g



王垠为什么看不起 Test Driven ? 这个要从他的研究背景和方向就很容易理解。他在读书时候写作业，老板的要求就远超过 Test 
Driven。程序不但要求从输入到输出是正确，还要求程序能倒推运行，即给出输出结果，能产生所有可能的输入。王垠做的，是逻辑编程的方向，目的是通过逻辑推导演算去保证程序的正确性。为此不难理解，为什么他对测试是那么不以为然
—— 用大量测试就能保证程序逻辑正确么？



我做过的各类Python项目，代码总量的50%左右是单元测试。经过这个级别的单元测试覆盖，确保了底层函数基本不会出错，这样高层功能的调试才更方便。同时也是这个覆盖程度确保了，被测试工程师发现bug的可能性已经很低了。

我给自己的单元测试设置了5个级别：

1. Level1：正常流程可用，即一个函数在输入正确的参数时，会有正确的输出
2. Level2：异常流程可抛出逻辑异常，即输入参数有误时，不能抛出系统异常，而是用自己定义的逻辑异常通知上层调用代码其错误之处
3. Level3：极端情况和边界数据可用，对输入参数的边界情况也要单独测试，确保输出是正确有效的
4. Level4：所有分支、循环的逻辑走通，不能有任何流程是测试不到的
5. Level5：输出数据的所有字段验证，对有复杂数据结构的输出，确保每个字段都是正确的

如上的单元测试分级是我2007年整理出来的，后来在我做的各种项目中，一般只做到Level2，重要系统或者底层服务，要做到Level3或Level4。而很少做到Level5。即便如此，就已经实现了如上所说的，很难被测试工程师发现bug。





**即使我看了单元测试的书，也一头雾水，不知道怎么测试我的系统：**

这种情况可能是你代码本身导致的，首先你要写具有**“可测性”**的代码，这意味着你不能写面向过程的，流水式的，几百行逻辑堆一起的代码（也叫意大利面代码，就像一盘意大利面一样搅在一起的代码。），你要学一些模块化技巧，**面向对象**和**函数式编程**理念，还有很多其它具体方法，比如能用本地变量，就不要用全局变量等等，让你的代码具有可测性，这些知识的学习应该放在单元测试之前。



一旦发现了个bug，就可以先把它表达成一个单元测试，然后通过debug这个单元测试来debug你的程序。以后再也不会一不小心重新引入这个bug了。



jest 提供一个 dom 树的快照功能，修改代码之后只需要比对前后两颗渲染的 dom 树是否相同，就可以得知是否出现了意外的 dom 树修改。它会自动的跟 dom 树快照进行比较，如果出现了比如 dom 上某个标签的增删或是属性的增删等就会报错，如果是确定要修改的，那就在保存快照。

有时候，我们可能只是对内部的逻辑进行修改或优化，此时并不会修改任何 UI，所以 dom 快照就可以让我们避免任何意外的渲染，因为 jsx 可以直接引入 js 变量进行渲染的缘故，所以我们很可能修改了这些变量从而导致 ui 显示出奇怪的现象。





容器组件 home，展示型组件 price、monthSelector

jest 测试、enzyme，展示型组件测试、容器型组件测试

react-router

TDD

type=”number“ type=“date”

children

flatten state =》 将复杂的 state 打平，将

扁平化概念的核心意义是：去除冗余、厚重和繁杂的装饰效果。

具体表现在去掉了多余的透视、纹理、渐变以及能做出3D效果的元素，这样可以让“信息”本身重新作为核心被凸显出来。同时在设计元素上，则强调了抽象、极简和符号化 ————以上是设计的扁平化。

不难想象，我们为什么要让数据也扁平化。那是为了更加能够让信息更加的凸显出来

对于多维数组，扁平化的目的就是让他降维。

redux context.provide

HOC 其实就是为了进行代码复用，其行为类似装饰器，叫做高阶组件是因为其以组件作为参数并且返回一个组件



put、patch

concurrently、create-react-app proxy

异步

loader

HOC 的单元测试，其实 HOC 就是增加新的 props 进去，所以做模拟的单元测试手动添加 props 进去即可

```js
    const wrapper = mount(
      <MemoryRouter>
        <CreatePage data={initData} actions={actions} match={match} />
      </MemoryRouter>
    )
```



有些东西是 promise 对象，这个时候可以模拟返回值`jest.fn().mockReturnValueOnce(Promise.resolve(''))`

有的时候需要测试 setState 之后的场景该怎么办呢？

```js
wrapper.update()
```

Chart.js for react 添加图表





对于要大量修改逻辑的，不用写太多单元测试。

对于极少修改的，比如展示型组件这种，要写单元测试。



