# UFT-8 编解码器

就跟 ASCII 编码用 0~127 位表示了特殊字符、大小写英文和数字一样，Unicode 编码，也是为每个字符给定了唯一的号码。同时，为了兼容以前用 ASCII 编码写出的软件，前面的 0~127 位跟 ASCII 是一样的。当然，Unicode 为了无所不包，让大多数主要语言的各个基本字都占了一个号码(单单汉语就是一大堆啊)，导致这个号码的数目庞大，而且还在不断增长中，也有人称之为“万国码”。

Unicode 最直接的表达就是 UTF-32，32 的意思是能表达 2 的 32 次方个字符，操作起来是跟 ASCII 一样的，比如说 “a“ 的 ASCII 编码是 `61`，而“启”字的 UTF-32 的编码是 `\u542f`，UTF-32 没有任何需要编解码的地方，跟 ASCII 一样只要系统支持，直接输出就是对应的字符。

> ASCII 因为数量少所以使用了人类易识别的十进制，而 UTF-32 由于数目太大使用了十六进制，前面的 `\u` 表明这是 Unicode 编码。

UTF-32 虽好，但其单个字符就占据 32 位，与 ASCII 相比所占据的空间要大了四倍，而计算机世界九成九以上的语言都是使用英文编程的，也就是说 ASCII 是完全能够满足的大部分需求了，而且相比 UTF-32 要节省很多空间。但是 Unicode 能解决乱码问题啊，谁也不想自己的中文注释或者是打印出来的中文变成一堆乱码吧。

所以我们有了两个问题：
1. 空间占用过高：UTF-32 作为 Unicode 编码的直接表达太占空间。
2. 国际化：希望能使用国际化，让各国编码问题变得简单的 Unicode 编码。

## UTF-8 的处理方式

UTF-8 就是为了解决以上两个问题而出现的，不仅能有 ASCII 的好处也能有 Unicode 的好处。

UTF-8 如何解决空间占用过高的问题呢？

答案是利用控制位的方式来实现，很容易发现 ASCII 并没有完整的利用完 8 比特的大小，因为 ASCII 的取值只有 0~127 也就是 2^7，还有最高的一位二进制没有利用到！

UTF-8 就利用了最高的一位做了文章，简单表达就是：如果最高一位是 0 的话，那么就做 ASCII 码处理。

按照 ASCII 码处理的话，一个 'a' 只占 1 字节，而按照 Unicode 处理的话，占 4 字节。

好极了，空间占用的问题被解决了！

---

那么，国际化怎么做呢？

解决空间问题时根据最高位是 0 来判断其是否是 ASCII 码，那么现在只要最高位跟 ASCII 区分开来，并且能够表达出 Unicode 的编码范围就可以解决问题了。

最高位与 ASCII 区分开很容易，只需要最高位不为 0 即可，那么如何表达出 Unicode 的编码范围呢？

答案是利用每个字符的首字节做控制位，UTF-8 将首字节的最高位作为控制位，规定首字节的最高位将会表达这一个字符将由几个字节构成，他们利用 1 来表明所需字节数，并用 0 进行分割，比如首位字节 110x xxxx 前面两个 1 说明这个字符由两个字节构成，1111 0xxx 说明这个字符由 4 个字节构成。

> 注意，控制位不会出现 10xx xxxx 这样的构成，因为代表单个字节将由头部为 0 的 ASCII 表达。

最高位得出了，那么首位字节之后的低字节怎么表达呢？

答案是低字节的头部统一使用 10 来表达，形如 10xx xxxx。

为什么用 10 呢？因为低字节的头部必须要跟最高字节的控制位和 ASCII 区分开来，那么头部为 0、110、1110、1111 这些就都不能被使用了。瞧，二进制 10 成了一个漏网之鱼，正好可以被低字节使用！

前文提出的两个问题就这样被 UTF-8 轻松解决。

**至此，我们有规则：头部 0 用以识别 ASCII，头部为 110、1110、11110、111110、... 用以识别 Unicode 编码的首字节，头部为 10 用以识别 Unicode 编码的低字节。**

**而根据以上规则进行编、解码的方式，我们就称之为 `UTF-8` 编码。**

最后来张表格感受一下：

|      Unicode 范围      |            UTF-8 编码方式            |
|:---------------------:|:-----------------------------------:|
|       0x00~0x7f       |               0xxxxxxx              |
|     0x0080~0x07ff     |          110xxxxx 10xxxxxx          |
|     0x0800~0xffff     |      1110xxxx 10xxxxxx 10xxxxxx     |
| 0x00010000~0x0010ffff | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |
|         ......        |                ......               |

> 注意分清字符、字节、二进制位之间的关系。

---

## 实现 UFT-8 编解码器

实现起来就非常简单了，根据规则走：头部 0 用以识别 ASCII，头部为 110、1110、11110、111110、... 用以识别 Unicode 编码的首字节，头部为 10 用以识别 Unicode 编码的低字节。

我们需要两个核心函数：一个编码函数能遵循以上规则将 Unicode 字符编码为 UTF-8 格式，一个解码函数能遵循以上规则将 Unicode 字符解码为 UTF-8 格式。

建立两个文件 UTF8.c、UTF8.h，往 UTF8.h 中写入：

<<< docs/blog/文章/UFT-8编解码器/UTF8.h

注意 ascii_1byte 0x7f 代表 0~127 的空间，用于表达 ASCII 的最大数据空间，其他同理。


然后就是 UTF8.c 具体的实现，为了方便阅读和修改，详细过程写在注释中。

<<< docs/blog/文章/UFT-8编解码器/UTF8.c