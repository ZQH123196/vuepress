# Unicode 与 UTF-8、UTF-16、UTF-32

## 前言
Unicode 是一种编码集。
UTF-xx 是 Unicode 编码方案的实现。

Unicode 规定了所有国际字符的编码，而 UTF-xx 则是将这种编码展现出来的一种手段，其中 UTF-32 编码相当于 Unicode 编码的转译。

Unicode 的版本很多，但主要曾历经两个阶段：
第一阶段：用两个字节，即 16 位二进制来表达国际字符。
第二阶段：用四个字节，即 32 位二进制来表达国际字符。

---

## UTF-8 的低字节标识位与容错
![上图图源：https://www.cnblogs.com/benbenalin/p/6953847.html](https://upload-images.jianshu.io/upload_images/5690889-be1f602718ca4047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


UTF-8 兼容 ASCII 码的做法是将最高位给置为 0，这表明这个字节是单字节的 ASCII 码。
UTF-8 表述非 ASCII 码的做法是一个字符的首字节用于标识表示这个字符所需要的字节数量。

标识位 10 只能出现在非 ASCII 码的低字节中，换言之，在 UTF-8 编码中以 10 开头的全部都是低字节。
低字节有了这个特性便具备了“校验”的能力，比如在读取了 UTF-8 编码的高字节后，可以根据后面连续低字节的数量来判断是否有字节丢失，换言之，只有高字节后面跟随着以 10 开头的才是正确的 UTF-8 编码。
以 110、1110、11110...... 开头的都不是，这样，字符边界就很好被判断了。

UTF-8 的容错性之所以强于 UTF-16，正是因为 UTF-8 中**首字节的跟低字节绝对不会混淆**的原因，因为低字节开头 10 的特性使其字符边界十分好判断，即使是存在部分字节的丢失，也能通过字符边界的判断来保证其他字符的正确表达。

UTF-16 的容错性就很差了，一段字符串如果有一个字节的丢失，那么在那个字节之后的所有文本都将会是乱码。因为 UTF-16 根本无法判断其字符边界。

---

## UTF-8 不需要字节序
UTF-8 没有字节序的概念，原因按顺序表述：
1. 明确字节进行网络传输时的顺序是确定的，系统读入读出都是一样的顺序。
2. 字节序是用来区分将**“二进制转译为屏幕上字符方式”**的一种方式（大小端），当一种编码方案规定一个字符是有多个字节组成时（两个或两个以上字节）我们才需要它。这是因为两个字节需要区分现后被处理的顺序才能被正确的转译，否则就是乱码了。
3. UTF-8 跟 UTF-16 的表达方式完全不同，UTF-8 是单字节和带有标识的多字节编码，UTF-16 是多字节编码。
4. UTF-8 在表达 ASCII 时是单字节编码，这不需要去考虑字节序的问题。
5. UTF-8 在表达非 ASCII 字符是是多字节编码，但是和常规一个字符由多个字节表达不同，UTF-8 是存在类似标记位一般的头部的，它将会利用在首字节的头部编码将自己的顺序给表达出来，即头部将会表述字符的位数，就像是那些网络协议的头部会表明自身的长度一样，并且标记位与数据位之间利用 0 来进行分割，其跟随的其他位头部则用 10 来表达。
6. 很明显的，由于 UTF-8 是自己进行了“位数”的控制，各个首字节其实是很占空间的~
7. UTF-8 依赖于其首字节来表述自身的长度，所以 UTF-8 的首字节是被最先读取的，就是说会往一个字节的高位向低位读 1，直到遇见 0 为止，读入几个 1 就代表有几个字节。
8. 由于 UTF-8 自己进行“位数控制的行为”，所以不需要字节序，因为 UTF-8 自己表达了顺序。



## UTF-8 与 BOM
字节序标记 BOM(ZERO WIDTH NO-BREAK SPACE 零宽度不中断空格) 是 Unicode 码点值为 FEFF (二进制：1111 1110 1111 1111) 的字符的别名，专门用于区分大端小端字节序。该字符是个无宽度的空格，也就是打印不可见的字符，区分与最常见的有宽度可见的空格。

UTF-8 没有字节序，所以

字节FE(二进制为1111 1110)和FF(二进制为1111 1111)在UTF-8编码中永远不会出现(因为UTF-8编码方式中，每个字节只能以0、110、1110、11110或10开头，详见后文介绍)。因此可以用称之为零宽度不中断空格(ZERO WIDTH NO-BREAK SPACE)的字符(Unicode字符名称为U+FEFF)作为字节顺序标记BOM来标明UTF-16或UTF-32文本的字节序。

## 问&答
* 为什么 Unicode 会出现？
由于网络的发展，ASCII 已经无法满足国际化的需求，所以出现了 Unicode 编码来解决问题。

* 为什么会有 Unicode 的第二阶段？
由于第一阶段所设定的 16 位不够了，所以来个第二阶段的 32 位，同时也是现行阶段。

* 为什么 Unicode 要兼容 ASCII 编码？
因为大部分的代码跟网页，是由 ASCII 编码写成，为了兼容过去的网页和程序，需要兼容 ASCII。

* Unicode 为什么会有多种编码实现？
因为需求，比如 UFT-8 在英文多的环境下可以大大节省空间，而 UTF-16 与 UTF-32 在**多语种**的情况下更易编写也更省空间。

* 为什么建议用 UTF-8？
因为多语种文本多的场景极少，从编写语言到库函数全是英文，一段展示中文的 html 页面，在计算机眼里可能英文比中文还多。

* UTF-8 的低字节为什么用 10 作标识位，为什么不用 1？
如果只要求低字节最高位是 1，就很可能跟首字节混淆并失去“校验”能力，考虑在丢失字节的情况下遇见一个低字节 11110xxx 的情况，这时候就会错误的判断这个低字节是用作标识字节数量的高字节，从而导致从这个字节起后面字节全部解析错误的情况。

* UTF-8 是用 8 位定长编码的意思么？
不是，UTF-8 是可变长编码，8 是指基础编码单元，UTF-8 其实是最低能用 8 位(一个编码单元)表示，最高能用 32 位（四个编码单元）表示。(16 位，24 位皆可)

* UTF-16 是 16 位定长编码的意思么？
不是，UTF-16 跟 UTF-8 一样都是可变长编码，但是二者的编码方式完全不同。16 是指基础编码单元，由于基础编码单元是 2 字节（16位）的，所以只能用 2 字节和 4 字节来表示。特别的 UTF-16 编码在 windows 老版本下由于被错误认为是定长编码，所以会有 bug。

* UTF-32 是定长编码么？
是的，因为 UTF-32 已经相当于 Unicode 编码本身。

* 为什么汉字排序不符合现代拼音序？
Unicode 码位的汉字排序是康熙字典序，而不是新华字典序（UTF-16 不能）。Unihan 数据库可用于实现拼音排序。

## 最终建议
* 编程时使用 UTF-8 准没错。
* 某些语言可能在 Unicode 编码中十分靠后，用 UTF-8 表达会太占空间，这时可以考虑 UTF-16 和 UTF-32 进行优化，毕竟 UTF-8 是亲近英语系的。


## 参考：
* [UTF-8 Everywhere](http://utf8everywhere.org/zh-cn)
* [wikipedia](https://en.wikipedia.org/wiki/Unicode)
* [Unicode字符集的编码方式以及码点、码元](https://www.cnblogs.com/benbenalin/p/6921553.html)
* [为什么utf-8没有字节序问题？](http://bbs.chinaunix.net/ thread-1680943-1-1.html)
