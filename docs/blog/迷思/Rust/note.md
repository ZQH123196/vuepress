# 乱瞧 Rust

- 由函数到范式，函数是简单的代码复用，而泛型则是更高级的代码复用。事实上泛型将会根据具体调用泛型的地方来生成对应的“函数”。

- <https://kaisery.github.io/trpl-zh-cn/ch10-00-generics.html>

- 说实在的，如果要解决指针的一些问题，比如指向同一个资源的多个指针到处乱飞，这样就很容易在不明不白的情况下创建野指针，因为可能不知道在哪里就被释放掉了。

- 而 rust 中对野生狂放的指针进行了限制，关进了笼子，rust  规定：在特定作用域中的特定数据有且只有一个可变引用，并且可变与不可变作用域内互斥存在。也就是说对于这些特定数据（clone  类）在这个作用域内只能有一个家伙持有可变引用，或者都是不可变引用。

- 只有一个人持有可变引用其实就代表着仅此人可以进行数据的修改，而同时可以存在多个不可变引用就代表这些人都可以读取但不能修改。这正好符合了一个写入多个读取，并且在写时不能读取的内存安全模型，至少在这个特定作用域内是如此，真素神奇，这也就是在语言层面的内存安全吧，因为这被当成了语言标准。

- 这个限制的好处是 Rust 可以在编译时就避免数据竞争。数据竞争（data  race）类似于竞态条件，它可由这三个行为造成：

- ​    两个或更多指针同时访问同一数据。

- ​    至少有一个指针被用来写入数据。

- ​    没有同步数据访问的机制。

- 我们 也  不能在拥有不可变引用的同时拥有可变引用。不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！然而，多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。

- 所有权贯穿 rust 的一切，包括引用类型也会导致所有权的移交，但是引用类型在 rust  中又被称作“借用”，原因就在于它会有对于所有权的操作，在它的生命结束的时候会将借来的所有权还回去，也就是说不会有 drop 的调用。

  

- match 的必须穷尽策略在程序员使用 option  的情况下，确实能够规避掉空值被使用的风险，但也会略微增加程序员的负担，因为穷尽一个不多的 enum 还好，如果很多的话就非常麻烦了。在 C、C++  中，enum 经常会定义很多值在里面，其实也可以用 switch 来全部判断，但是很麻烦。

- 为了解决这个让程序员懒得写的场景，rust 做了很多人性化的操作。_ => ()  通配符就很好。if let 看上去很棒，但是语法让人精神分裂，完全不能理解！

- 

- &str 本质上就是 slice，他可能来自 from  或是字面量。实际是个结构体，带有一个指向内存区的指针，和一个表示长度的值，来自 from 的就指向 from  申请的地方（堆上），而来自字面量的就指向编译器提前就申请的地方（栈上）。

- Rust  的编译器会保证消除某样数据结构前这个数据结构是清清白白没有拖家带口的，我的意思是在这个数据结构没有任何引用/借用的情况才能通过编译器～借用检查器～

- 这样就保证了我们的引用数据不会出现悬垂指针的情况。（有指针，但是指向的地址已被释放）

- python 中常用 _ 来当做临时变量，但这在 rust 中行不通，也许是 rust 自身不是  utf-8 的原因？毕竟 Python3 因为编码是 utf-8 的原因，连写中文变量名都是可以的...

- from 用来重载 ？ 运算符返回的结果类型。还可以链式调用，人性化的设计！

- Rust  中的泛型不会有任何性能损失，因为在编译之前就会转译为实际需要的各种函数、结构体，这可以说是我见过干活最多的编译器。

- Rust 的 trait 给我的感觉很像是元编程，很接近 C++  中的虚函数和纯虚函数，你可以实现也可以只是用来站位，他们的目的都是定义一个实现某些目标“所必需的行为”的集合。其实就是编程规范，更多的是用在框架的编写上，规定你必须要实现什么以避免一些可能的错误和不恰当的行为，不过这个约束力因为没有派生跟继承的关系，不得不自己在泛型中手动声明要“遵循”那些  trait。trait bound 即：让泛型添加筛选功能，可以指定泛型类型必须要实现那些 trait 才可以适用，否则不行。

- 一般来说，我们可以用抽象来轻易的理解 trait，trait  的中译就是特性。如果我们写一个程序，用以描述世界人民的饮食习惯，这个时候我们就可以抽取其中的特性，来规范后来者的代码编写，比如日本、中国都用筷子，那么在实现日本、中国的内地饮食习惯时，就可以将“使用筷子”这个方法给抽象出来做成一个特性。？？？

- 嗯，看上去有点像是 PY 鸭子类型和 C++  虚函数的结合版？归根结底都是代码复用的方案，就是不知道那个更优。

- 难以理解的隐式行为：自动解引用，真的是很麻烦。他会在实现了解引用特性的结构上生效，自己解除引用以方便计算。

- 但素，理解之后发现，自动解引用很好用，你不再需要使用 *  号去手动的解引用，这使得在编写代码的时候可以忽略解引用这个操作。我的意思是，多用引用，而不需要承担书写 * 号的负担，并且不需要考虑你需要解几层引用。

- 代码被读比被写的次数更多，到底是为了读服务还是为了写的舒适服务。

- 

- Rust 已经存在的三个所有权制度之一。这是 Rust 最独特和最令人信服的一个特点，其中  Rust 开发人员应该相当熟悉。所有权即 Rust 如何实现其最大目标和内存安全。这里有几个不同的概念，每一个概念都有它自己的章节：

- - [所有权](http://doc.rust-lang.org/stable/book/ownership.html)，即正在读的这篇文章。
  - 借用，和与它们相关的功能‘引用’
  - [生存期](http://doc.rust-lang.org/stable/book/lifetimes.html)，借用的先进理念

- 生命周期是为引用而生，与所有权之类的都无关，引用拥有着自己的生存期（当前作用域），而所有权是能被移交的，理论上没有调用  drop 就一直存在，会被移交而已。

- 二者的表现也不同，引用只关注作用域，而所有权则关注被移交的变量，在变量销毁时销毁（作用域结束），所以一直被移交的话，所有权就可以一直存在。